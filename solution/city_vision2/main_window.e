note
	description	: "Main window for this application"
	author		: "Generated by the New Vision2 Application Wizard."
	date		: "$Date: 2007/7/16 12:52:13 $"
	revision	: "1.0.0"

class
	MAIN_WINDOW

inherit
	EV_TITLED_WINDOW
		redefine
			initialize
		end

	KL_SHARED_FILE_SYSTEM
		undefine
			default_create,
			copy
		end

create
	default_create

feature {NONE} -- Initialization

	initialize
			-- Build the interface for this window.
		local
			t: TIME
		do
			Precursor {EV_TITLED_WINDOW}
				-- Create and add the toolbar.
			build_standard_toolbar
			upper_bar.extend (create {EV_HORIZONTAL_SEPARATOR})
			upper_bar.extend (standard_toolbar)
				-- Create and add the status bar.
			build_standard_status_bar
			lower_bar.extend (standard_status_bar)
			build_main_container
			extend (main_container)
				-- Execute `request_close_window' when the user clicks
				-- on the cross in the title bar.
			close_request_actions.extend (agent request_close_window)
				-- Set the title of the window
			set_title (Window_title)
				-- Set the initial size of the window
			set_size ((canvas.width*1.2).floor, (canvas.height*1.2).floor)
			create t.make_now
			create random.set_seed (t.compact_time)
		end

feature {NONE} -- Widgets

	standard_toolbar: EV_TOOL_BAR
			-- Standard toolbar for this window

	standard_status_bar: EV_STATUS_BAR
			-- Standard status bar for this window

	standard_status_label: EV_LABEL
			-- Label situated in the standard status bar.
			--
			-- Note: Call `standard_status_label.set_text (...)' to change the text
			--       displayed in the status bar.

	main_container: EV_VERTICAL_BOX
			-- Main container (contains all widgets displayed in this window)

	canvas: TRAFFIC_CITY_CANVAS
			-- The Canvas Widget

	viewport: EV_VIEWPORT
			-- To display the canvas

	vb: EV_VERTICAL_BOX
			-- Map manipulation area

feature {NONE} -- GUI building

	build_standard_toolbar
			-- Create and populate the standard toolbar.
		require
			toolbar_not_yet_created: standard_toolbar = Void
		local
			toolbar_item: EV_TOOL_BAR_BUTTON
			toolbar_pixmap: EV_PIXMAP
		do
			create standard_toolbar
			create toolbar_item
			create toolbar_pixmap
			toolbar_pixmap.set_with_named_file (File_system.absolute_pathname (File_system.pathname_from_file_system ("..\image\open.png", Windows_file_system)))
			toolbar_item.set_pixmap (toolbar_pixmap)
			toolbar_item.select_actions.extend (agent choose_file)
			standard_toolbar.extend (toolbar_item)
			create toolbar_item
			create toolbar_pixmap
			toolbar_pixmap.set_with_named_file (File_system.absolute_pathname (File_system.pathname_from_file_system ("..\image\zoom_in.png", Windows_file_system)))
			toolbar_item.set_pixmap (toolbar_pixmap)
			toolbar_item.select_actions.extend (agent zoom_in)
			standard_toolbar.extend (toolbar_item)
			create toolbar_item
			create toolbar_pixmap
			toolbar_pixmap.set_with_named_file (File_system.absolute_pathname (File_system.pathname_from_file_system ("..\image\zoom_out.png", Windows_file_system)))
			toolbar_item.set_pixmap (toolbar_pixmap)
			toolbar_item.select_actions.extend (agent zoom_out)
			standard_toolbar.extend (toolbar_item)
		ensure
			toolbar_created: standard_toolbar /= Void and then  not standard_toolbar.is_empty
		end

	build_standard_status_bar
			-- Create and populate the standard toolbar.
		require
			status_bar_not_yet_created:
				standard_status_bar = Void and then
				standard_status_label = Void
		local
			env: EV_ENVIRONMENT
		do
				-- Create the status bar.
			create standard_status_bar
			standard_status_bar.set_border_width (2)

				-- Populate the status bar.
			create standard_status_label.make_with_text ("Please open a map...")
			standard_status_label.align_text_left
			standard_status_bar.extend (standard_status_label)

			create env
			env.application.add_idle_action (agent update_status_label)
		ensure
			status_bar_created:
				standard_status_bar /= Void and then
				standard_status_label /= Void
		end

	build_main_container
			-- Create and populate `main_container'.
		require
			main_container_not_yet_created: main_container = Void
		local
			hb1, hb: EV_HORIZONTAL_BOX
			fr: EV_FRAME
			r: EV_HORIZONTAL_RANGE
			l: EV_LABEL
			rad: EV_CHECK_BUTTON
			table: EV_TABLE
			toggle: EV_TOGGLE_BUTTON
			button: EV_BUTTON
		do
			create viewport
			viewport.set_offset (0, 0)
			create vb
			create hb1
			create fr
			create canvas.make
			create main_container
			create table

			viewport.set_minimum_height (400)
			viewport.set_minimum_width (600)
			viewport.extend (canvas)
			fr.extend (viewport)
			canvas.set_zoom_limits (0.5, 10.0)
			viewport.resize_actions.force_extend (agent resize_canvas)


			-- free movings
			create l.make_with_text ("Free movings (0..100):")
			create r.make_with_value_range (create {INTEGER_INTERVAL}.make (0, 100))
			r.set_value (0)
			r.set_minimum_width (100)
			r.change_actions.extend (agent add_free_movings)

			create hb
			hb.extend (l)
			hb.extend (r)
			vb.extend (hb)

			-- Line vehicles
			create l.make_with_text ("Vehicles/Line (0..10):")
			create r.make_with_value_range (create {INTEGER_INTERVAL}.make (0, 10))
			r.set_value (0)
			r.set_minimum_width (100)
			r.change_actions.extend (agent add_line_vehicles)
			create hb
			hb.extend (l)
			hb.extend (r)
			vb.extend (hb)

			-- Passengers
			create l.make_with_text ("Passengers (0..100):")
			create r.make_with_value_range (create {INTEGER_INTERVAL}.make (0, 100))
			r.set_value (0)
			r.set_minimum_width (100)
			r.change_actions.extend (agent add_passengers)
			create hb
			hb.extend (l)
			hb.extend (r)
			vb.extend (hb)

			-- Paths
			create l.make_with_text ("Paths (0..10):")
			create r.make_with_value_range (create {INTEGER_INTERVAL}.make (0, 10))
			r.set_value (0)
			r.set_minimum_width (100)
			r.change_actions.extend (agent add_paths)
			create hb
			hb.extend (l)
			hb.extend (r)
			vb.extend (hb)

			-- Dispatch Taxis
			create button.make_with_text ("+office")
			button.select_actions.extend (agent add_taxi_office)
			create l.make_with_text ("taxis (0..10):")
			create r.make_with_value_range (create {INTEGER_INTERVAL}.make (0, 10))
			r.set_value (0)
			r.set_minimum_width (100)
			r.change_actions.extend (agent add_dispatch_taxi)
			create hb
			hb.extend (button)
			hb.extend (l)
			hb.extend (r)
			vb.extend (hb)

			-- taxi
			create hb
			create button.make_with_text ("+taxi")
			button.select_actions.extend (agent add_taxi)
			hb.extend (button)
			create button.make_with_text ("-taxi")
			button.select_actions.extend (agent remove_taxi)
			hb.extend (button)
			vb.extend (hb)




			-- Hide/show map
			create rad.make_with_text ("Show map")
			rad.toggle
			rad.select_actions.extend (agent toggle_map_hidden (rad))
			create hb
			hb.extend (rad)

			-- Hide/show lines
			create rad.make_with_text ("Show lines")
			rad.toggle
			rad.select_actions.extend (agent toggle_lines_hidden (rad))
			hb.extend (rad)

			-- Hide/show lines
			create rad.make_with_text ("Show roads")
			rad.toggle
			rad.select_actions.extend (agent toggle_roads_hidden (rad))
			hb.extend (rad)
			vb.extend (hb)

			-- Test highlight/unhighlight feature
			create toggle.make_with_text ("Highlight random map items")
			toggle.select_actions.extend (agent toggle_highlight (toggle))
			vb.extend (toggle)

			-- Test creation
			create hb
			create button.make_with_text ("+station")
			button.select_actions.extend (agent add_place)
			hb.extend (button)

			create button.make_with_text ("+line")
			button.select_actions.extend (agent add_line)
			hb.extend (button)

			create button.make_with_text ("+connection")
			button.select_actions.extend (agent add_line_connection)
			hb.extend (button)

			create button.make_with_text ("+road")
			button.select_actions.extend (agent add_road)
			hb.extend (button)
			vb.extend (hb)

			-- Test deletion
			create hb
			create button.make_with_text ("-station")
			button.select_actions.extend (agent remove_place)
			hb.extend (button)

			create button.make_with_text ("-line")
			button.select_actions.extend (agent remove_line)
			hb.extend (button)

			create button.make_with_text ("-connection")
			button.select_actions.extend (agent remove_line_connection)
			hb.extend (button)

			create button.make_with_text ("-road")
			button.select_actions.extend (agent remove_road)
			hb.extend (button)

			vb.extend (hb)
			vb.disable_sensitive

			hb1.extend (vb)
			hb1.disable_item_expand (vb)
			hb1.extend (fr)
			main_container.extend (hb1)
			main_container.set_padding (10)
		ensure
			main_container_created: main_container /= Void
		end

feature {NONE} -- Implementation

	request_close_window
			-- The user wants to close the window
		local
			question_dialog: EV_CONFIRMATION_DIALOG
		do
			create question_dialog.make_with_text (Label_confirm_close_window)
			question_dialog.show_modal_to_window (Current)

			if question_dialog.selected_button.is_equal ((create {EV_DIALOG_CONSTANTS}).ev_ok) then
					-- Destroy the window
				destroy;

					-- End the application
					--| TODO: Remove this line if you don't want the application
					--|       to end when the first window is closed..
				(create {EV_ENVIRONMENT}).application.destroy
			end
		end

	choose_file
			-- Open file dialog and choose a map to load.
		local
			dlg: EV_FILE_OPEN_DIALOG
		do
			create dlg.make_with_title ("Open map file")
			dlg.filters.extend (["*.xml", "Traffic xml files (*.xml)"] )
			dlg.open_actions.extend (agent open_file (dlg))
			dlg.show_modal_to_window (Current)
		end

	open_file (a_dlg: EV_FILE_OPEN_DIALOG)
			-- File dialog was closed, now load a map.
		local
			loader: TRAFFIC_MAP_LOADER
			dlg: EV_MESSAGE_DIALOG
		do
			create loader.make (a_dlg.file_name)
			loader.disable_dump_loading
			loader.load_map
			if not loader.has_error then
				if canvas.city /= Void and then canvas.city.time.is_time_running then
					canvas.city.time.reset
				end
				canvas.set_city (loader.city)
				create point_randomizer.make (loader.city.center, loader.city.radius)
				create path_randomizer.set_city (loader.city)
				resize_canvas
				add_buildings
				canvas.city.time.set_speedup (50)
				canvas.city.time.start
				move_to_center
				vb.enable_sensitive
			else
				create dlg.make_with_text ("Error parsing" + a_dlg.file_name)
				dlg.show
			end
		end

	add_buildings
			-- Add buildings to the city.
		local
			r: TRAFFIC_BUILDING_RANDOMIZER
		do
			create r.set_city (canvas.city)
			r.generate_random_buildings (10, canvas.city.radius/3, 3)
			from
				r.last_buildings.start
			until
				r.last_buildings.off
			loop
				canvas.city.put_building (r.last_buildings.item_for_iteration)
				r.last_buildings.forth
			end
			r.generate_random_buildings (15, canvas.city.radius*2/3, 2)
			from
				r.last_buildings.start
			until
				r.last_buildings.off
			loop
				canvas.city.put_building (r.last_buildings.item_for_iteration)
				r.last_buildings.forth
			end
			r.generate_random_buildings (100, canvas.city.radius, 1)
			from
				r.last_buildings.start
			until
				r.last_buildings.off
			loop
				canvas.city.put_building (r.last_buildings.item_for_iteration)
				r.last_buildings.forth
			end
		end

	add_line_vehicles (a_value: INTEGER)
			-- Add as many line vehicles to the city, so that there are `a_value' per line (or remove some if needed).
		local
			tram: TRAFFIC_TRAM
			bus: TRAFFIC_BUS
			i: INTEGER
		do
			if canvas.city /= Void then
				canvas.city.trams.wipe_out
				canvas.city.busses.wipe_out
				if a_value > 0 then
					from
						canvas.city.lines.start
					until
						canvas.city.lines.after
					loop
						from
							i := 1
						until
							i > a_value or else i > canvas.city.lines.item_for_iteration.segment_count
						loop
							if canvas.city.lines.item_for_iteration.type.name.is_equal ("tram") then
								create tram.make_with_line (canvas.city.lines.item_for_iteration)
								tram.set_to_station (canvas.city.lines.item_for_iteration.i_th (i))
								canvas.city.put_tram (tram)
								tram.start
							elseif canvas.city.lines.item_for_iteration.type.name.is_equal ("bus") then
								create bus.make_with_line (canvas.city.lines.item_for_iteration)
								bus.set_to_station (canvas.city.lines.item_for_iteration.i_th (i))
								bus.set_speed (5)
								bus.set_reiterate (True)
								canvas.city.put_bus (bus)
								bus.start
							end
							i := i + 1
						end
						canvas.city.lines.forth
					end
				end
			end
		end

	add_free_movings (a_value: INTEGER)
			-- Add `a_value' number of free moving objects (or remove some if needed).
		local
			moving: TRAFFIC_FREE_MOVING
		do
			if canvas.city /= Void then
				if a_value > canvas.city.free_movings.count then
					-- Add more
					from
					until
						canvas.city.free_movings.count >= a_value
					loop
						point_randomizer.generate_point_array (7)
						create moving.make_with_points (point_randomizer.last_array, 1.5)
						canvas.city.put_free_moving (moving)
						moving.set_reiterate (True)
						moving.start
					end
				elseif a_value < canvas.city.free_movings.count then
					-- Remove
					canvas.city.free_movings.prune_last (canvas.city.free_movings.count - a_value)
				end
			end
		end

	add_passengers (a_value: INTEGER)
			-- Add `a_value' number of passengers (or remove some if needed).
		local
			passenger: TRAFFIC_PASSENGER
			i: INTEGER
		do
			if a_value > canvas.city.passengers.count then
				-- Add more
				from
				until
					canvas.city.passengers.count >= a_value
				loop
					path_randomizer.generate_route (6)
					random.forth
					if path_randomizer.last_route.first /= Void then
						create passenger.make_with_route (path_randomizer.last_route, random.double_item*3 + 0.1)
						canvas.city.put_passenger (passenger)
						passenger.set_reiterate (True)
						passenger.go
					end
					i := i + 1
				end
			elseif a_value < canvas.city.passengers.count then
				-- Remove
				canvas.city.passengers.prune_last (canvas.city.passengers.count - a_value)
			end
		end

	add_paths (a_value: INTEGER)
			-- Add `a_value' number of paths to the city (or remove if needed).
		local
			g, b: INTEGER
			p: ARRAY [TRAFFIC_STATION]
			p1, p2: TRAFFIC_STATION
			c: TRAFFIC_ROUTE_CALCULATOR
		do
			if a_value > canvas.city.routes.count then
				-- Add more
				p := canvas.city.stations.to_array
				create c.set_city (canvas.city)
				from
				until
					canvas.city.routes.count >= a_value
				loop
					random.forth
					p1 := p.item (random.item \\ p.count + 1)
					random.forth
					p2 := p.item (random.item \\ p.count + 1)
					if p1 /= p2 then
						c.find_shortest_path (p1, p2)
						if c.route /= Void then
							random.forth
							g := random.item \\ 256
							random.forth
							b := random.item \\ 256
							canvas.city.put_route (c.route)
						end
					end
				end
			elseif a_value < canvas.city.routes.count then
				-- Remove
				canvas.city.routes.prune_last (canvas.city.routes.count - a_value)
			end
		end

	add_place
			-- Add place.
		local
			p: TRAFFIC_STATION
			x, y: INTEGER
		do
			-- Create new place
			random.forth
			create p.make ("New station" + random.item.out)
			random.forth
			x := random.item \\ (2*canvas.city.radius.floor)
			random.forth
			y := random.item \\ (2*canvas.city.radius.floor)
			p.set_location (create {TRAFFIC_POINT}.make (canvas.city.center.x + x - canvas.city.radius, canvas.city.center.y + y - canvas.city.radius))
			canvas.city.put_station (p)
--			canvas.redraw
		end

	add_line
			-- Add line.
		local
			l: TRAFFIC_LINE
			lc1, lc2: TRAFFIC_LINE_SEGMENT
			r, g, b: INTEGER
			p1, p2: TRAFFIC_STATION
			s1, s2: TRAFFIC_STOP
			p: ARRAY [TRAFFIC_STATION]
			pp: DS_ARRAYED_LIST [TRAFFIC_POINT]
		do
			random.forth
			r := random.item \\ 256
			random.forth
			g := random.item \\ 256
			random.forth
			b := random.item \\ 256
			create l.make ("Line" + random.item.out, create {TRAFFIC_TYPE_TRAM}.make)
			l.set_color (create {TRAFFIC_COLOR}.make_with_rgb (r, g, b))
			p := canvas.city.stations.to_array
			p1 := p.item (random.item \\ p.count + 1)
			random.forth
			p2 := p.item (random.item \\ p.count + 1)
			if p1.has_stop (l) then
				s1 := p1.stop (l)
			else
				create s1.make_with_location (p1, l, create {TRAFFIC_POINT}.make_from_other (p1.location))
			end
			if p2.has_stop (l) then
				s2 := p2.stop (l)
			else
				create s2.make_with_location (p2, l, create {TRAFFIC_POINT}.make_from_other (p2.location))
			end
			create pp.make (2)
			pp.force_last (create {TRAFFIC_POINT}.make_from_other (s1.location))
			pp.force_last (create {TRAFFIC_POINT}.make_from_other (s2.location))
			create lc1.make (s1, s2, l.type, pp)
			create pp.make (2)
			pp.force_last (create {TRAFFIC_POINT}.make_from_other (s2.location))
			pp.force_last (create {TRAFFIC_POINT}.make_from_other (s1.location))
			create lc2.make (s2, s1, l.type, pp)
			l.put_last (lc1, lc2)
			canvas.city.put_line (l)
		end

	add_line_connection
			-- Add line connection.
		local
			l: TRAFFIC_LINE
			lc1, lc2: TRAFFIC_LINE_SEGMENT
			p1, p2: TRAFFIC_STATION
			s1, s2: TRAFFIC_STOP
			pt: ARRAY [TRAFFIC_STATION]
			lt: ARRAY [TRAFFIC_LINE]
			pp: DS_ARRAYED_LIST [TRAFFIC_POINT]
		do
			lt := canvas.city.lines.to_array
			if lt.count > 0 then
				l := lt.item ((random.item \\ lt.count) + 1)
				pt := canvas.city.stations.to_array
				if l.terminal_2 /= Void then
					if l.terminal_2.has_stop (l) then
						s1 := l.terminal_2.stop (l)
					else
						create s1.make_with_location (l.terminal_2, l, create {TRAFFIC_POINT}.make_from_other (l.terminal_2.location))
					end
				else
					random.forth
					p1 := pt.item ((random.item \\ pt.count) + 1)
					if p1 /= Void and then p1.has_stop (l) then
						s1 := p1.stop (l)
					else
						create s1.make_with_location (p1, l, create {TRAFFIC_POINT}.make_from_other (p1.location))
					end
				end
				random.forth
				p2 := pt.item ((random.item \\ pt.count) + 1)
				if p2.has_stop (l) then
					s2 := p2.stop (l)
				else
					create s2.make_with_location (p2, l, create {TRAFFIC_POINT}.make_from_other (p2.location))
				end
				create pp.make (2)
				pp.force_last (create {TRAFFIC_POINT}.make_from_other (s1.location))
				pp.force_last (create {TRAFFIC_POINT}.make_from_other (s2.location))
				create lc1.make (s1, s2, l.type, pp)
				create pp.make (2)
				pp.force_last (create {TRAFFIC_POINT}.make_from_other (s2.location))
				pp.force_last (create {TRAFFIC_POINT}.make_from_other (s1.location))
				create lc2.make (s2, s1, l.type, pp)
				l.put_last (lc1, lc2)
			end
		end

	add_road
			-- Add road.
		local
			r: TRAFFIC_ROAD
			rc1, rc2: TRAFFIC_ROAD_SEGMENT
			n1, n2: TRAFFIC_NODE
			pt: ARRAY [TRAFFIC_STATION]
		do
			pt := canvas.city.stations.to_array
			random.forth
			n1 := pt.item ((random.item \\ pt.count) + 1).dummy_node
			random.forth
			n2 := pt.item ((random.item \\ pt.count) + 1).dummy_node

			create rc1.make (n1, n2, create {TRAFFIC_TYPE_STREET}.make, canvas.city.graph.id_manager.next_free_index)
			create rc2.make (n2, n1, create {TRAFFIC_TYPE_STREET}.make, canvas.city.graph.id_manager.next_free_index)
			create r.make (rc1, rc2)
			canvas.city.put_road (r)
--			canvas.redraw
		end

	add_taxi_office
			-- Add taxi office.
		local
			r, g, b: INTEGER
			l_taxi: TRAFFIC_DISPATCH_TAXI
			l_office: TRAFFIC_TAXI_OFFICE
		do
			-- create random color for the office
			random.forth
			r := random.item \\ 256
			random.forth
			g := random.item \\ 256
			random.forth
			b := random.item \\ 256
			random.forth

			create l_office.make_with_color (r, g, b)
			point_randomizer.generate_point_array (5)
			create l_taxi.make_with_office (l_office, point_randomizer.last_array)
			l_office.add_taxi (l_taxi)
			canvas.city.put_taxi_office (l_office)
			point_randomizer.generate_point_array (5)
			create l_taxi.make_with_office (l_office, point_randomizer.last_array)
			l_office.add_taxi (l_taxi)
		end

	add_dispatch_taxi (a_value: INTEGER)
			-- Add dispatch_taxi
		local
			l_taxi: TRAFFIC_DISPATCH_TAXI
			l_office: TRAFFIC_TAXI_OFFICE
		do
			if not canvas.city.taxi_offices.is_empty then
				l_office := canvas.city.taxi_offices.last
				if l_office.taxis.count <= a_value then
					-- ad taxis until there are at least `a_value' taxis
					from
					until
						l_office.taxis.count >= a_value
					loop
						point_randomizer.generate_point_array (5)
						create l_taxi.make_with_office (l_office, point_randomizer.last_array)
						l_office.add_taxi (l_taxi)
					end

				else
					-- remove taxis until there are at most `a_value' taxis
					from
					until
						l_office.taxis.count <= a_value
					loop
						l_office.remove_taxi (l_office.taxis.last)
					end
				end
			end
		end

	add_taxi
			-- Add taxi
		local
			l_taxi: TRAFFIC_TAXI
		do
			point_randomizer.generate_point_array (5)
			create l_taxi.make_random (point_randomizer.last_array)
			canvas.city.put_taxi (l_taxi)
		end

	remove_taxi
			-- Remove taxi
		local
			l_taxi:  TRAFFIC_DISPATCH_TAXI
			removed: BOOLEAN
		do
			from
				canvas.city.taxis.start
			until
				canvas.city.taxis.after or removed
			loop
				l_taxi ?= canvas.city.taxis.item_for_iteration
				if l_taxi = Void then
					canvas.city.taxis.delete (canvas.city.taxis.item_for_iteration)
					removed := True
				else
					canvas.city.taxis.forth
				end
			end
		end

	remove_place
			-- Remove random city items.
		local
			p: TRAFFIC_STATION
			pt: ARRAY [TRAFFIC_STATION]
		do
			pt := canvas.city.stations.to_array
			if pt.count > 0 then
				p := pt.item ((random.item \\ pt.count) + 1)
				if p.is_removable then
					canvas.city.stations.remove (p.name)
				end
			end
--			canvas.redraw
		end

	remove_line
			-- Add random city items
		local
			l: TRAFFIC_LINE
			lt: ARRAY [TRAFFIC_LINE]
		do
			lt := canvas.city.lines.to_array
			if lt.count > 0 then
				l := lt.item ((random.item \\ lt.count) + 1)
				canvas.city.lines.remove (l.name)
			end
		end

	remove_line_connection
			-- Add random city items
		local
			l: TRAFFIC_LINE
			lt: ARRAY [TRAFFIC_LINE]
		do
			lt := canvas.city.lines.to_array
			if lt.count > 0 then
				l := lt.item ((random.item \\ lt.count) + 1)
				l.remove_all_segments
				random.forth
				l := lt.item ((random.item \\ lt.count) + 1)
				if l.segment_count >= 1 then
					l.remove_first
				end
				random.forth
				l := lt.item ((random.item \\ lt.count) + 1)
				if l.segment_count >= 1 then
					l.remove_last
				end
			end
		end

	remove_road
			-- Add random city items
		local
			r: TRAFFIC_ROAD
			rt: ARRAY [TRAFFIC_ROAD]
		do
			rt := canvas.city.roads.to_array
			random.forth
			if rt.count > 0 then
				r := rt.item ((random.item \\ rt.count) + 1)
				if r.is_removable then
					canvas.city.roads.remove (r.id)
				end
			end
		end

	toggle_map_hidden (a_check_box: EV_CHECK_BUTTON)
			--
		do
			if a_check_box.is_selected then
				canvas.disable_city_hidden
			else
				canvas.enable_city_hidden
			end
		end

	toggle_lines_hidden (a_check_box: EV_CHECK_BUTTON)
			--
		do
			if a_check_box.is_selected then
				canvas.line_representations.show
			else
				canvas.line_representations.hide
			end
		end

	toggle_roads_hidden (a_check_box: EV_CHECK_BUTTON)
			--
		do
			if a_check_box.is_selected then
				canvas.road_representations.show
			else
				canvas.road_representations.hide
			end
		end

	toggle_highlight (a_toggle: EV_TOGGLE_BUTTON)
			--
		do
			if a_toggle.is_selected then
				canvas.city.stations.first.highlight
				canvas.city.lines.first.highlight
				canvas.city.line_segments.last.highlight
				canvas.city.roads.first.highlight
				canvas.city.buildings.first.spotlight
			else
				canvas.city.stations.first.unhighlight
				canvas.city.lines.first.unhighlight
				canvas.city.line_segments.last.unhighlight
				canvas.city.roads.first.unhighlight
				canvas.city.buildings.first.unspotlight
			end
		end


	update_status_label
			--
		do
			if canvas.city /= Void and then canvas.city.time.is_time_running then
				standard_status_label.set_text (canvas.city.time.out)
			end
		end

	resize_canvas
			-- Set up canvas.
		local
			w: INTEGER
			h: INTEGER
		do
			w := (viewport.width).max (1)
			h := (viewport.height).max (1)
			canvas.set_size (w, h)
			canvas.set_minimum_size (w, h)
			viewport.set_item_size (w, h)
		end

	move_to_center
			-- Center map on screen.
		local
			xdiff, ydiff: REAL_64
			canvas_center: REAL_COORDINATE
		do
			canvas_center := client_to_map_coordinates ((canvas.width/2).floor, (canvas.height/2).floor)
			xdiff := canvas.city.center.x - canvas_center.x
			ydiff := (-1)*canvas.city.center.y - canvas_center.y
			if xdiff /= 0 or ydiff /= 0 then
				canvas.go_down (ydiff)
				canvas.go_left (xdiff)
			end
			canvas.redraw
		end

	zoom_in
			-- Zoom in.
		do
			Canvas.zoom_in (Zoom_factor_stepwise)
		end

	zoom_out
			-- Zoom out.
		do
			Canvas.zoom_out (Zoom_factor_stepwise)
		end

feature {NONE} -- Implementation

	point_randomizer: TRAFFIC_POINT_RANDOMIZER
			-- Generator for list of random points

	path_randomizer: TRAFFIC_ROUTE_RANDOMIZER
			-- Generator for random paths

	random: RANDOM
			-- Random number generator for passenger speed

feature -- Conversion

	client_to_map_coordinates (x, y: INTEGER): REAL_COORDINATE
			-- Map position corresponding to client coordinates (`x', `y')
		local
			lx: REAL_64
			ly: REAL_64
			xperc: REAL_64
			yperc: REAL_64
			h: INTEGER
			org: REAL_COORDINATE
		do
			lx := x / 1
			ly := y / 1

			xperc := lx / (canvas.parent.client_width)
			h := (canvas.parent.client_height).max (1)
			yperc := (h - ly) / h

			org := canvas.visible_area.lower_left
			create Result.make (
				(org.x + xperc * canvas.visible_area.width).rounded,
				(org.y + yperc * canvas.visible_area.height).rounded)

		ensure
			Result_exists: Result /= Void
		end

feature {NONE} -- Implementation / Constants

	Window_title: STRING = "city_vision2"
			-- Title of the window.

	Window_width: INTEGER = 800
			-- Initial width for this window.

	Window_height: INTEGER = 400
			-- Initial height for this window.

	Label_confirm_close_window: STRING = "You are about to close this window.%NClick OK to proceed."
			-- String for the confirmation dialog box that appears
			-- when the user try to close the first window.

	Zoom_factor_stepwise: REAL_64 = 0.05
			-- Stepwise zoom factor

end -- class MAIN_WINDOW
